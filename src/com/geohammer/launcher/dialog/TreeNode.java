package org.ucdm.launcher.dialog;


// server Desktop-p4oiufb with credential DAS das

import org.apache.commons.io.FileUtils;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class TreeNode<T> implements Iterable<TreeNode<T>> {

	public T data;
	public TreeNode<T> parent;
	public List<TreeNode<T>> children;

	public boolean isRoot() {
		return parent == null;
	}

	public boolean isLeaf() {
		return children.size() == 0;
	}

	private List<TreeNode<T>> elementsIndex;

	public TreeNode(T data) {
		this.data = data;
		this.children = new LinkedList<TreeNode<T>>();
		this.elementsIndex = new LinkedList<TreeNode<T>>();
		this.elementsIndex.add(this);
	}

	public TreeNode<T> addChild(T child) {
		TreeNode<T> childNode = new TreeNode<T>(child);
		childNode.parent = this;
		this.children.add(childNode);
		this.registerChildForSearch(childNode);
		return childNode;
	}

	public int getLevel() {
		if (this.isRoot())
			return 0;
		else
			return parent.getLevel() + 1;
	}

	private void registerChildForSearch(TreeNode<T> node) {
		elementsIndex.add(node);
		if (parent != null) parent.registerChildForSearch(node);
	}

	public TreeNode<T> findTreeNode(Comparable<T> cmp) {
		for (TreeNode<T> element : this.elementsIndex) {
			T elData = element.data;
			if (cmp.compareTo(elData) == 0)
				return element;
		}

		return null;
	}

	@Override
	public String toString() {
		return data != null ? data.toString() : "[data null]";
	}

	@Override
	public Iterator<TreeNode<T>> iterator() {
		TreeNodeIter<T> iter = new TreeNodeIter<T>(this);
		return iter;
	}

	public static TreeNode<File> createDirTree(File folder) {
		if (!folder.isDirectory()) {
			throw new IllegalArgumentException("folder is not a Directory");
		}
		TreeNode<File> DirRoot = new TreeNode<File>(folder);
		for (File file : folder.listFiles()) {
			if(file.isHidden()) continue;
			if (file.isDirectory()) {
				appendDirTree(file, DirRoot);
			} else {
				//appendFile(file, DirRoot);
			}
		}
		return DirRoot;
	}

	public static void appendDirTree(File folder, TreeNode<File> DirRoot)
	{
		DirRoot.addChild(folder);
		for (File file : folder.listFiles()) {
			if (file.isDirectory()) {
				appendDirTree(file, DirRoot.children.get(DirRoot.children.size() - 1));
			} else {
				//appendFile(file, DirRoot.children.get(DirRoot.children.size() - 1));
			}
		}
	}

	public static void appendFile(File file, TreeNode<File> filenode) {
		filenode.addChild(file);
	}


	public static String renderDirectoryTree(TreeNode<File> tree) {
		List<StringBuilder> lines = renderDirectoryTreeLines(tree);
		String newline = System.getProperty("line.separator");
		StringBuilder sb = new StringBuilder(lines.size() * 20);
		for (StringBuilder line : lines) {
			sb.append(line);
			sb.append(newline);
		}
		return sb.toString();
	}

	public static List<StringBuilder> renderDirectoryTreeLines(TreeNode<File> tree) {
		List<StringBuilder> result = new LinkedList<>();
		result.add(new StringBuilder().append(tree.data.getName()));
		Iterator<TreeNode<File>> iterator = tree.children.iterator();
		while (iterator.hasNext()) {
			List<StringBuilder> subtree = renderDirectoryTreeLines(iterator.next());
			if (iterator.hasNext()) {
				addSubtree(result, subtree);
			} else {
				addLastSubtree(result, subtree);
			}
		}
		return result;
	}

	private static void addSubtree(List<StringBuilder> result, List<StringBuilder> subtree) {
		Iterator<StringBuilder> iterator = subtree.iterator();
		//subtree generated by renderDirectoryTreeLines has at least one
		//line which is tree.getData()
		result.add(iterator.next().insert(0, "├── "));
		while (iterator.hasNext()) {
			result.add(iterator.next().insert(0, "│   "));
		}
	}

	private static void addLastSubtree(List<StringBuilder> result, List<StringBuilder> subtree) {
		Iterator<StringBuilder> iterator = subtree.iterator();
		//subtree generated by renderDirectoryTreeLines has at least
		//one line which is tree.getData()
		result.add(iterator.next().insert(0, "└── "));
		while (iterator.hasNext()) {
			result.add(iterator.next().insert(0, "    "));
		}
	}

	public static void main(String[] args) {
		//File file = new File("C:\\Don");
		File file = new File("K:\\");
		TreeNode<File> DirTree = createDirTree(file);
		String result = renderDirectoryTree(DirTree);
		System.out.println(result);
		
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss");
		Timestamp timestamp = new Timestamp(System.currentTimeMillis());
		System.out.println(sdf.format(timestamp) + "  hx40914\n");
//		try {
//			File newTextFile = new File("./DirectoryTree.txt");
//			FileWriter fw = new FileWriter(newTextFile);
//			fw.write(sdf.format(timestamp) + "  hx40914\n");
//			fw.write(result);
//			fw.close();
//
//		} catch (IOException iox) {
//			iox.printStackTrace();
//		}
	}
	
	enum ProcessStages {
		ProcessParent, ProcessChildCurNode, ProcessChildSubNode
	}
	
	public class TreeNodeIter<T> implements Iterator<TreeNode<T>> {

		private TreeNode<T> treeNode;

		public TreeNodeIter(TreeNode<T> treeNode) {
			this.treeNode = treeNode;
			this.doNext = ProcessStages.ProcessParent;
			this.childrenCurNodeIter = treeNode.children.iterator();
		}

		private ProcessStages doNext;
		private TreeNode<T> next;
		private Iterator<TreeNode<T>> childrenCurNodeIter;
		private Iterator<TreeNode<T>> childrenSubNodeIter;

		@Override
		public boolean hasNext() {

			if (this.doNext == ProcessStages.ProcessParent) {
				this.next = this.treeNode;
				this.doNext = ProcessStages.ProcessChildCurNode;
				return true;
			}

			if (this.doNext == ProcessStages.ProcessChildCurNode) {
				if (childrenCurNodeIter.hasNext()) {
					TreeNode<T> childDirect = childrenCurNodeIter.next();
					childrenSubNodeIter = childDirect.iterator();
					this.doNext = ProcessStages.ProcessChildSubNode;
					return hasNext();
				}

				else {
					this.doNext = null;
					return false;
				}
			}
			
			if (this.doNext == ProcessStages.ProcessChildSubNode) {
				if (childrenSubNodeIter.hasNext()) {
					this.next = childrenSubNodeIter.next();
					return true;
				}
				else {
					this.next = null;
					this.doNext = ProcessStages.ProcessChildCurNode;
					return hasNext();
				}
			}

			return false;
		}

		@Override
		public TreeNode<T> next() {
			return this.next;
		}

		@Override
		public void remove() {
			throw new UnsupportedOperationException();
		}

	}
}
